Only in at-home-modifier-evdev/src/: .deps
diff -ru xf86-input-evdev-2.10.6/src/emuMB.c at-home-modifier-evdev/src/emuMB.c
--- xf86-input-evdev-2.10.6/src/emuMB.c	2018-05-28 19:33:18.000000000 -0700
+++ at-home-modifier-evdev/src/emuMB.c	2019-06-03 10:30:27.479598779 -0700
@@ -45,7 +45,6 @@
 
 static Atom prop_mbemu     = 0; /* Middle button emulation on/off property */
 static Atom prop_mbtimeout = 0; /* Middle button timeout property */
-static Atom prop_mbbuton   = 0; /* Middle button target button property */
 /*
  * Lets create a simple finite-state machine for 3 button emulation:
  *
@@ -185,21 +184,14 @@
 EvdevMBEmuTimer(InputInfoPtr pInfo)
 {
     EvdevPtr pEvdev = pInfo->private;
+    int	sigstate;
     int id;
-    int mapped_id;
 
-#if HAVE_THREADED_INPUT
-    input_lock();
-#else
-    int sigstate = xf86BlockSIGIO();
-#endif
+    sigstate = xf86BlockSIGIO ();
 
     pEvdev->emulateMB.pending = FALSE;
     if ((id = stateTab[pEvdev->emulateMB.state][4][0]) != 0) {
-        mapped_id = abs(id);
-        if (mapped_id == 2)
-            mapped_id = pEvdev->emulateMB.button;
-        EvdevPostButtonEvent(pInfo, mapped_id,
+        EvdevPostButtonEvent(pInfo, abs(id),
                              (id >= 0) ? BUTTON_PRESS : BUTTON_RELEASE);
         pEvdev->emulateMB.state =
             stateTab[pEvdev->emulateMB.state][4][2];
@@ -208,11 +200,7 @@
                     pEvdev->emulateMB.state);
     }
 
-#if HAVE_THREADED_INPUT
-    input_unlock();
-#else
-    xf86UnblockSIGIO(sigstate);
-#endif
+    xf86UnblockSIGIO (sigstate);
     return 0;
 }
 
@@ -231,7 +219,6 @@
 {
     EvdevPtr pEvdev = pInfo->private;
     int id;
-    int mapped_id;
     int *btstate;
     int ret = FALSE;
 
@@ -250,10 +237,7 @@
 
     if ((id = stateTab[pEvdev->emulateMB.state][*btstate][0]) != 0)
     {
-        mapped_id = abs(id);
-        if (mapped_id == 2)
-            mapped_id = pEvdev->emulateMB.button;
-        EvdevQueueButtonEvent(pInfo, mapped_id, (id >= 0));
+        EvdevQueueButtonEvent(pInfo, abs(id), (id >= 0));
         ret = TRUE;
     }
     if ((id = stateTab[pEvdev->emulateMB.state][*btstate][1]) != 0)
@@ -277,7 +261,9 @@
 }
 
 
-void EvdevMBEmuWakeupHandler(WAKEUP_HANDLER_ARGS)
+void EvdevMBEmuWakeupHandler(pointer data,
+                             int i,
+                             pointer LastSelectMask)
 {
     InputInfoPtr pInfo = (InputInfoPtr)data;
     EvdevPtr     pEvdev = (EvdevPtr)pInfo->private;
@@ -291,7 +277,9 @@
     }
 }
 
-void EvdevMBEmuBlockHandler(BLOCK_HANDLER_ARGS)
+void EvdevMBEmuBlockHandler(pointer data,
+                            struct timeval **waitTime,
+                            pointer LastSelectMask)
 {
     InputInfoPtr    pInfo = (InputInfoPtr) data;
     EvdevPtr        pEvdev= (EvdevPtr) pInfo->private;
@@ -310,23 +298,12 @@
 EvdevMBEmuPreInit(InputInfoPtr pInfo)
 {
     EvdevPtr pEvdev = (EvdevPtr)pInfo->private;
-    int bt;
 
     pEvdev->emulateMB.enabled = xf86SetBoolOption(pInfo->options,
                                                   "Emulate3Buttons",
                                                   FALSE);
     pEvdev->emulateMB.timeout = xf86SetIntOption(pInfo->options,
                                                  "Emulate3Timeout", 50);
-    bt = xf86SetIntOption(pInfo->options, "Emulate3Button", 2);
-    if (bt < 0 || bt > EVDEV_MAXBUTTONS) {
-        xf86IDrvMsg(pInfo, X_WARNING, "Invalid Emulate3Button value: %d\n",
-                    bt);
-        xf86IDrvMsg(pInfo, X_WARNING, "Middle button emulation disabled.\n");
-
-        pEvdev->emulateMB.enabled = FALSE;
-    }
-
-    pEvdev->emulateMB.button = bt;
 }
 
 void
@@ -358,7 +335,6 @@
 {
     InputInfoPtr pInfo  = dev->public.devicePrivate;
     EvdevPtr     pEvdev = pInfo->private;
-    int bt;
 
     if (atom == prop_mbemu)
     {
@@ -374,18 +350,6 @@
 
         if (!checkonly)
             pEvdev->emulateMB.timeout = *((CARD32*)val->data);
-    } else if (atom == prop_mbbuton)
-    {
-        if (val->format != 8 || val->size != 1 || val->type != XA_INTEGER)
-            return BadMatch;
-
-        bt = *((CARD8*)val->data);
-
-        if (bt < 0 || bt > EVDEV_MAXBUTTONS)
-            return BadValue;
-
-        if (!checkonly)
-            pEvdev->emulateMB.button = bt;
     }
 
     return Success;
@@ -423,15 +387,5 @@
         return;
     XISetDevicePropertyDeletable(dev, prop_mbtimeout, FALSE);
 
-    prop_mbbuton = MakeAtom(EVDEV_PROP_MIDBUTTON_BUTTON,
-                              strlen(EVDEV_PROP_MIDBUTTON_BUTTON),
-                              TRUE);
-    rc = XIChangeDeviceProperty(dev, prop_mbbuton, XA_INTEGER, 8, PropModeReplace, 1,
-                                &pEvdev->emulateMB.button, FALSE);
-
-    if (rc != Success)
-        return;
-    XISetDevicePropertyDeletable(dev, prop_mbbuton, FALSE);
-
     XIRegisterPropertyHandler(dev, EvdevMBEmuSetProperty, NULL, NULL);
 }
diff -ru xf86-input-evdev-2.10.6/src/emuThird.c at-home-modifier-evdev/src/emuThird.c
--- xf86-input-evdev-2.10.6/src/emuThird.c	2018-05-28 19:33:18.000000000 -0700
+++ at-home-modifier-evdev/src/emuThird.c	2019-06-03 10:30:27.479598779 -0700
@@ -89,19 +89,12 @@
     InputInfoPtr      pInfo    = (InputInfoPtr)arg;
     EvdevPtr          pEvdev   = pInfo->private;
     struct emulate3B *emu3B    = &pEvdev->emulate3B;
+    int               sigstate = 0;
 
-#if HAVE_THREADED_INPUT
-    input_lock();
-#else
-    int sigstate = xf86BlockSIGIO();
-#endif
+    sigstate = xf86BlockSIGIO ();
     emu3B->state = EM3B_EMULATING;
     Evdev3BEmuPostButtonEvent(pInfo, emu3B->button, BUTTON_PRESS);
-#if HAVE_THREADED_INPUT
-    input_unlock();
-#else
-    xf86UnblockSIGIO(sigstate);
-#endif
+    xf86UnblockSIGIO (sigstate);
     return 0;
 }
 
diff -ru xf86-input-evdev-2.10.6/src/evdev.c at-home-modifier-evdev/src/evdev.c
--- xf86-input-evdev-2.10.6/src/evdev.c	2018-05-28 19:33:18.000000000 -0700
+++ at-home-modifier-evdev/src/evdev.c	2019-06-03 10:30:27.481598779 -0700
@@ -91,14 +91,14 @@
 
 /* Any of those triggers a proximity event */
 static int proximity_bits[] = {
-        BTN_TOOL_PEN,
-        BTN_TOOL_RUBBER,
-        BTN_TOOL_BRUSH,
-        BTN_TOOL_PENCIL,
-        BTN_TOOL_AIRBRUSH,
-        BTN_TOOL_FINGER,
-        BTN_TOOL_MOUSE,
-        BTN_TOOL_LENS,
+    BTN_TOOL_PEN,
+    BTN_TOOL_RUBBER,
+    BTN_TOOL_BRUSH,
+    BTN_TOOL_PENCIL,
+    BTN_TOOL_AIRBRUSH,
+    BTN_TOOL_FINGER,
+    BTN_TOOL_MOUSE,
+    BTN_TOOL_LENS,
 };
 
 static int EvdevOn(DeviceIntPtr);
@@ -127,6 +127,8 @@
 static Atom prop_virtual;
 static Atom prop_scroll_dist;
 
+static InputInfoPtr ahmLastEventDevice;
+
 static int EvdevSwitchMode(ClientPtr client, DeviceIntPtr device, int mode)
 {
     InputInfoPtr pInfo;
@@ -145,27 +147,27 @@
     }
 
     switch (mode) {
-        case Absolute:
-            pEvdev->flags &= ~EVDEV_RELATIVE_MODE;
-            if (valuator_mask_fetch(pEvdev->old_vals, 0, &val))
-                valuator_mask_set(pEvdev->abs_vals, 0, val);
-            if (valuator_mask_fetch(pEvdev->old_vals, 1, &val))
-                valuator_mask_set(pEvdev->abs_vals, 1, val);
-            valuator_mask_zero(pEvdev->old_vals);
-            break;
+    case Absolute:
+        pEvdev->flags &= ~EVDEV_RELATIVE_MODE;
+        if (valuator_mask_fetch(pEvdev->old_vals, 0, &val))
+            valuator_mask_set(pEvdev->abs_vals, 0, val);
+        if (valuator_mask_fetch(pEvdev->old_vals, 1, &val))
+            valuator_mask_set(pEvdev->abs_vals, 1, val);
+        valuator_mask_zero(pEvdev->old_vals);
+        break;
 
-        case Relative:
-            pEvdev->flags |= EVDEV_RELATIVE_MODE;
-            if (valuator_mask_fetch(pEvdev->abs_vals, 0, &val))
-                valuator_mask_set(pEvdev->old_vals, 0, val);
-            if (valuator_mask_fetch(pEvdev->abs_vals, 1, &val))
-                valuator_mask_set(pEvdev->old_vals, 1, val);
-            valuator_mask_unset(pEvdev->abs_vals, 0);
-            valuator_mask_unset(pEvdev->abs_vals, 1);
-            break;
+    case Relative:
+        pEvdev->flags |= EVDEV_RELATIVE_MODE;
+        if (valuator_mask_fetch(pEvdev->abs_vals, 0, &val))
+            valuator_mask_set(pEvdev->old_vals, 0, val);
+        if (valuator_mask_fetch(pEvdev->abs_vals, 1, &val))
+            valuator_mask_set(pEvdev->old_vals, 1, val);
+        valuator_mask_unset(pEvdev->abs_vals, 0);
+        valuator_mask_unset(pEvdev->abs_vals, 1);
+        break;
 
-        default:
-            return XI_BadMode;
+    default:
+        return XI_BadMode;
     }
 
     return Success;
@@ -274,7 +276,11 @@
     return &pEvdev->queue[pEvdev->num_queue - 1];
 }
 
-void
+/*
+ * Returns 0 on failure, 1 on success.
+ * In the original, upstream code, it's a void function.
+ */
+int
 EvdevQueueKbdEvent(InputInfoPtr pInfo, struct input_event *ev, int value)
 {
     int code = ev->code + MIN_KEYCODE;
@@ -282,17 +288,394 @@
 
     /* Filter all repeated events from device.
        We'll do softrepeat in the server, but only since 1.6 */
-    if (value == 2)
-        return;
+    if (value == 2){
+	    return 1;
+    }
 
     if ((pQueue = EvdevNextInQueue(pInfo)))
     {
         pQueue->type = EV_QUEUE_KEY;
         pQueue->detail.key = code;
         pQueue->val = value;
+        return 1;
+    }
+    else{
+        return 0;
+    }
+}
+
+/*
+ * Inside of AhmStep2, the keycode is X value. Restore the linux/input.h
+ * value which EvdevQueueKbdEvent accepts.
+ */
+static int
+WrapEvdevQueueKbdEvent(InputInfoPtr pInfo, struct input_event *ev, int value, int code){
+    ev->code = code - MIN_KEYCODE;
+    return EvdevQueueKbdEvent(pInfo, ev, value);
+}
+
+/* If the transmod "orig" key is pressed long enough and thus
+   timed out, it returns 1. Otherwise 0 */
+static int ahmTimedOutP(long int lastSec, long int lastUsec, struct input_event *ev, int timeOut){
+
+    /* timeOut is not set */
+    if(timeOut == 0){
+        return 0;
+    }
+
+    if( (ev->time.tv_sec - lastSec) * 1000
+        + (ev->time.tv_usec - lastUsec) / 1000
+        > timeOut){
+        return 1;
+    }else{
+        return 0;
+    }
+}
+
+/*
+ * Handles transmod and timeout
+ * code is X code, i.e. ev->code + MIN_KEYCODE
+ */
+static void
+AhmStep2(InputInfoPtr pInfo, struct input_event *ev, int value, int code)
+{
+    EvdevPtr pEvdev = pInfo->private;
+
+    int lastPressCode;
+
+    unsigned int * transModTable = pEvdev->transModTable;
+    int * transModCount = pEvdev->transModCount;
+
+    unsigned int * transModPressed = pEvdev->transModPressed;
+    Time * ahmTimePressed = pEvdev->ahmTimePressed;
+    
+    lastPressCode = pEvdev->lastPressCode;
+
+    if(value == 1){
+        pEvdev->lastPressCode = code;
+     }
+
+    if((value == 0)
+       && transModTable[lastPressCode]
+       && (lastPressCode != code)
+       && transModTable[code]
+       && (pEvdev->lastValue == 1)
+       && pEvdev->ahmFreezeTT){
+        /* Implements AhmFreezeTT */
+        transModCount[transModTable[lastPressCode]]--;
+        if(transModCount[transModTable[lastPressCode]] <= 0){
+            WrapEvdevQueueKbdEvent(pInfo, ev, 0, transModTable[lastPressCode]);
+        }
+        if(transModCount[transModTable[lastPressCode]] < 0){
+            /*
+             * Usually this doesn't happen, but not never, either.
+             * Thus in fact this line is necessary.
+             */
+            transModCount[transModTable[lastPressCode]] = 0;
+        }
+         WrapEvdevQueueKbdEvent(pInfo, ev, 1, lastPressCode);
+        pEvdev->transModFreeze[lastPressCode] = 1;
+
+        /* Treat the latest keycode as usual in the following. */
+    }
+
+    
+    
+    if(transModTable[code]){
+        if(pEvdev->transModFreeze[code] == 1){
+            /*
+             * When a freeze happens is explained above.
+             * If it's frozen, send the original key code.
+ v            */
+            WrapEvdevQueueKbdEvent(pInfo, ev, value, code);
+            pEvdev->transModFreeze[code] = 0;
+        }else{
+            /* Transmod, not frozen */
+
+            if(value == 1){
+                /* press */
+
+                /*
+                 * Role of transModCount: suppose both key a and b are translated
+                 * to left shift. Press a, b, and release b. Then it should be 'B'.
+                 * But without transModCount, first the shift would be released,
+                 * so lower b be emitted.
+                 */
+                transModCount[transModTable[code]]++;
+                // WrapEvdevQueueKbdEvent(pInfo, ev, 1, transModTable[code]);
+                transModPressed[code] = 1;
+                ahmTimePressed[code] = GetTimeInMillis();
+
+                Time theTime = GetTimeInMillis();
+                
+                if(theTime - pEvdev->lastPlainPressTime > 225) {
+                    WrapEvdevQueueKbdEvent(pInfo, ev, 1, transModTable[code]);
+                    transModPressed[code] = 2;
+                } else {
+                    WrapEvdevQueueKbdEvent(pInfo, ev, 1, code);
+                    transModPressed[code] = 3;
+                }
+
+            }else{
+                /* release */
+                transModCount[transModTable[code]]--;
+                if(transModCount[transModTable[code]] <= 0
+                   && transModPressed[code] == 2){
+                    WrapEvdevQueueKbdEvent(pInfo, ev, 0, transModTable[code]);
+
+                }
+                if(transModCount[transModTable[code]] < 0){
+                    /*
+                     * Usually this doesn't happen, but not never, either.
+                     * Thus in fact this line is necessary.
+                     */
+                    transModCount[transModTable[code]] = 0;
+                }
+
+                if((transModPressed[code] == 3)
+                   | ((lastPressCode == code)
+                      && (ahmLastEventDevice == pInfo)
+                      && (ahmTimedOutP(pEvdev->lastEventTime.tv_sec,
+                                       pEvdev->lastEventTime.tv_usec,
+                                       ev, pEvdev->ahmTimeout) == 0)
+                       )){
+                    /*
+                     * Simple press and release of a transMod key, so
+                     * send the original code.
+                     */
+                    if(transModPressed[code] != 3){
+                        WrapEvdevQueueKbdEvent(pInfo, ev, 1, code);
+                    }
+                    WrapEvdevQueueKbdEvent(pInfo, ev, 0, code);
+                }
+
+                ahmTimePressed[code] = 0;
+                transModPressed[code] = 0;
+                   
+            }
+        }
+    }else{
+        /* Plain key */
+        if(value){
+            Time theTime = GetTimeInMillis();
+                
+            transModCount[code]++;
+
+            /* int i; */
+            /* for(i=0; i<256; i++) { */
+
+            /*     if(ahmTimePressed[i] > 0 */
+            /*        && transModPressed[i] == 1 */
+            /*        && (theTime - ahmTimePressed[i]) > 125) { */
+            /*         WrapEvdevQueueKbdEvent(pInfo, ev, 1, transModTable[i]); */
+            /*         transModPressed[i] = 2;                     */
+            /*     } else if((theTime - ahmTimePressed[i]) <= 125) { */
+            /*         WrapEvdevQueueKbdEvent(pInfo, ev, 1, i); */
+            /*         transModPressed[i] = 3; */
+            /*     } */
+            /* } */
+             
+            WrapEvdevQueueKbdEvent(pInfo, ev, 1, code);
+            pEvdev->lastPlainPressTime = GetTimeInMillis();
+        }else{
+            transModCount[code]--;
+            if(transModCount[code] <= 0){
+                WrapEvdevQueueKbdEvent(pInfo, ev, 0, code);
+            }
+            if(transModCount[code] < 0){
+                /*
+                 * Usually this doesn't happen, but not never, either.
+                 * Thus in fact this line is necessary.
+                 */
+                transModCount[code] = 0;
+            }
+
+        }
+    }
+    pEvdev->lastValue = value;
+    ahmLastEventDevice = pInfo;
+}
+
+/* Handles reset and ahmDelay before AhmStep2 */
+static void
+AhmStep1(InputInfoPtr pInfo, struct input_event *ev, int value){
+    /*
+     * Meaning of ev->code is described in linux/input.h, "Keys and buttons"
+     * section.
+     * code + MIN_KEYCODE is the value used by X, listed in
+     * /usr/share/X11/xkb/keycodes/evdev.
+     *
+     * Meaning of value: 0: release, 1: press, 2: autorepeat.
+     * Notice that autorepeat is _sent by kernel input driver_. Don't
+     * confuse it with X server autorepeat which is set by xset command.
+     */
+    int code = ev->code + MIN_KEYCODE;
+    EvdevPtr pEvdev = pInfo->private;
+
+    int* ahmDelayedCode = pEvdev->ahmDelayedCode;
+
+    /*
+     * Autorepeat has to be filtered for ahm, too.
+     * See also the comment in EvdevQueueKbdEvent.
+     * Early return will also be implemented in upstream 2.7.0.
+     */
+    if(value == 2){
+        return;
+    }
+
+    /* Reset part */
+    if (pEvdev->ahmResetTime &&
+        (ev->time.tv_sec - pEvdev->lastEventTime.tv_sec >
+         pEvdev->ahmResetTime)){
+        /*
+         * (more than) ahmResetTime (sec) has elapsed since the last press event.
+         * Release all translated modifiers, and reset transModCount and
+         * freeze table.
+         */
+        int c;
+        for(c = MIN_KEYCODE; c < 256; c++){
+
+            if(pEvdev->transModTable[c]){
+                /*
+                 * I think release of transModTable[c] suffices,
+                 * and release of c is not necessary.
+                 */
+                WrapEvdevQueueKbdEvent(pInfo, ev, 0, pEvdev->transModTable[c]);
+            }
+            pEvdev->transModCount[c] = 0;
+            pEvdev->transModFreeze[c] = 0;
+        }
+        pEvdev->ahmDelayedKeys = 0;
+    }
+
+    /* Delay part. */
+
+    /* How many keys are already delayed? */
+    switch(pEvdev->ahmDelayedKeys){
+    case 0:
+        if(pEvdev->ahmDelayTable[code] && value){
+            ahmDelayedCode[0] = code;
+            pEvdev->ahmDelayedKeys = 1;
+        }else{
+            AhmStep2(pInfo, ev, value, code);
+        }
+        break;
+    case 1:
+        if(value == 0){
+            /* Release. Replay it. */
+            AhmStep2(pInfo, ev, 1, ahmDelayedCode[0]);
+
+            AhmStep2(pInfo, ev, 0, code);
+            pEvdev->ahmDelayedKeys = 0;
+        }else{
+            /* Another key is pressed. Queue this second event, too.*/
+            ahmDelayedCode[1] = code;
+            pEvdev->ahmDelayedKeys = 2;
+        }
+        break;
+    case 2:
+        pEvdev->ahmDelayedKeys = 0;
+        if( (value == 0) && (code == ahmDelayedCode[0]) ){
+            /* Gist of ahmDelay. */
+            AhmStep2(pInfo, ev, 1, code);
+            AhmStep2(pInfo, ev, 0, code);
+            AhmStep2(pInfo, ev, 1, ahmDelayedCode[1]);
+        }else{
+            /* Nothing special. Replay all, and bye. */
+            AhmStep2(pInfo, ev, 1, ahmDelayedCode[0]);
+            AhmStep2(pInfo, ev, 1, ahmDelayedCode[1]);
+            AhmStep2(pInfo, ev, value, code);
+        }
+        break;
+    }
+    pEvdev->lastEventTime.tv_sec  = ev->time.tv_sec;
+    pEvdev->lastEventTime.tv_usec = ev->time.tv_usec;
+}
+
+/*
+ * (ahm) I don't know the exact spec of RegisterBlockAndWakeupHandlers.
+ * I merely guessed it from emuMB.c which is also a part of
+ * xf86-input-evdev.
+ */
+
+/*
+ * Really send queued key events, implementing AhmPaddingInterval.
+ *
+ * This function is called using timer. If padding is necessary,
+ * postpone these events.
+ *
+ * Simple sleeping doesn't work; it simply blocks.
+ */
+static void AhmWakeupHandler(pointer data, __attribute__ ((unused)) int ii,
+                             pointer __attribute__ ((unused)) LastSelectMask){
+    InputInfoPtr pInfo = (InputInfoPtr) data;
+    EvdevPtr  pEvdev = (EvdevPtr) pInfo->private;
+    int ms;
+
+    if(pEvdev->ahmQueueTop != pEvdev->ahmQueueBottom){
+        ms = pEvdev->ahmTimerExpires - GetTimeInMillis();
+        if(ms <= 0){
+            int i, lim;
+            unsigned int lastKey = 0;
+
+            lim = (pEvdev->ahmQueueTop < pEvdev->ahmQueueBottom) ?
+                pEvdev->ahmQueueBottom : pEvdev->ahmQueueBottom + AHM_QUEUE_SIZE;
+
+            for (i = pEvdev->ahmQueueTop; i < lim; i++){
+                if((pEvdev->transModTable[pEvdev->ahmQueueKeys[i % AHM_QUEUE_SIZE]]
+                    == lastKey) && lastKey){
+                    pEvdev->ahmTimerExpires = GetTimeInMillis() +
+                        pEvdev->ahmPaddingInterval;
+                    break;
+                }else
+                    xf86PostKeyboardEvent(pInfo->dev,
+                                          pEvdev->ahmQueueKeys[i % AHM_QUEUE_SIZE],
+                                          pEvdev->ahmQueueValues[i % AHM_QUEUE_SIZE]);
+                lastKey = pEvdev->ahmQueueKeys[i % AHM_QUEUE_SIZE];
+            }
+            pEvdev->ahmQueueTop = i % AHM_QUEUE_SIZE;
+        }
+    }
+}
+
+
+static void AhmBlockHandler(pointer data,
+                            struct timeval **waitTime,
+                            __attribute__ ((unused)) pointer LastSelectMask)
+{
+    InputInfoPtr    pInfo = (InputInfoPtr) data;
+    EvdevPtr        pEvdev= (EvdevPtr) pInfo->private;
+    int             ms;
+
+    if(pEvdev->ahmQueueBottom != pEvdev->ahmQueueTop){
+        ms = pEvdev->ahmTimerExpires - GetTimeInMillis();
+        if(ms <= 0){
+            ms = 0;
+        }
+        AdjustWaitForDelay(waitTime, ms);
     }
 }
 
+static void AhmRegisterTimers(InputInfoPtr pInfo){
+    EvdevPtr        pEvdev= (EvdevPtr) pInfo->private;
+    if(!pEvdev->flags & EVDEV_KEYBOARD_EVENTS){
+        return;
+    }
+    RegisterBlockAndWakeupHandlers(AhmBlockHandler,
+                                   AhmWakeupHandler,
+                                   (pointer)pInfo);
+}
+
+static void AhmFinalise(InputInfoPtr pInfo){
+    EvdevPtr        pEvdev= (EvdevPtr) pInfo->private;
+    if(!pEvdev->flags & EVDEV_KEYBOARD_EVENTS){
+        return;
+    }
+    RemoveBlockAndWakeupHandlers(AhmBlockHandler,
+                                 AhmWakeupHandler,
+                                 (pointer)pInfo);
+}
+
 void
 EvdevQueueButtonEvent(InputInfoPtr pInfo, int button, int value)
 {
@@ -304,6 +687,7 @@
         pQueue->detail.key = button;
         pQueue->val = value;
     }
+    ahmLastEventDevice = pInfo;
 }
 
 void
@@ -433,10 +817,10 @@
     int val;
 
     if (pEvdev->abs_vals) {
-            if (valuator_mask_fetch(pEvdev->abs_vals, 0, &val))
-                    valuator_mask_set(pEvdev->old_vals, 0, val);
-            if (valuator_mask_fetch(pEvdev->abs_vals, 1, &val))
-                    valuator_mask_set(pEvdev->old_vals, 1, val);
+        if (valuator_mask_fetch(pEvdev->abs_vals, 0, &val))
+            valuator_mask_set(pEvdev->old_vals, 0, val);
+        if (valuator_mask_fetch(pEvdev->abs_vals, 1, &val))
+            valuator_mask_set(pEvdev->old_vals, 1, val);
     }
 
     /* Apply transformations on relative coordinates */
@@ -551,16 +935,6 @@
         }
     }
 
-    /* Wacom's last frame resets all values to 0, including x/y.
-       Skip over this. */
-    if (prox_state == 0) {
-        int v;
-        if (valuator_mask_fetch(pEvdev->abs_vals, 0, &v) && v == 0)
-            valuator_mask_unset(pEvdev->abs_vals, 0);
-        if (valuator_mask_fetch(pEvdev->abs_vals, 1, &v) && v == 0)
-            valuator_mask_unset(pEvdev->abs_vals, 1);
-    }
-
     if ((prox_state && !pEvdev->in_proximity) ||
         (!prox_state && pEvdev->in_proximity))
     {
@@ -608,7 +982,7 @@
     if (button)
         EvdevQueueButtonEvent(pInfo, button, value);
     else
-        EvdevQueueKbdEvent(pInfo, ev, value);
+        AhmStep1(pInfo, ev, value);
 }
 
 /**
@@ -625,25 +999,25 @@
     value = ev->value;
 
     switch (ev->code) {
-        default:
-            /* Ignore EV_REL events if we never set up for them. */
-            if (!(pEvdev->flags & EVDEV_RELATIVE_EVENTS) &&
-                    ev->code != REL_WHEEL && ev->code != REL_DIAL &&
-                    ev->code != REL_HWHEEL)
-                return;
-
-            /* Handle mouse wheel emulation */
-            if (EvdevWheelEmuFilterMotion(pInfo, ev))
-                return;
+    default:
+        /* Ignore EV_REL events if we never set up for them. */
+        if (!(pEvdev->flags & EVDEV_RELATIVE_EVENTS) &&
+            ev->code != REL_WHEEL && ev->code != REL_DIAL &&
+            ev->code != REL_HWHEEL)
+            return;
 
-            pEvdev->rel_queued = 1;
-            map = pEvdev->rel_axis_map[ev->code];
+        /* Handle mouse wheel emulation */
+        if (EvdevWheelEmuFilterMotion(pInfo, ev))
+            return;
 
-            if (valuator_mask_isset(pEvdev->rel_vals, map))
-                value += valuator_mask_get(pEvdev->rel_vals, map);
+        pEvdev->rel_queued = 1;
+        map = pEvdev->rel_axis_map[ev->code];
 
-            valuator_mask_set(pEvdev->rel_vals, map, value);
-            break;
+        if (valuator_mask_isset(pEvdev->rel_vals, map))
+            value += valuator_mask_get(pEvdev->rel_vals, map);
+
+        valuator_mask_set(pEvdev->rel_vals, map, value);
+        break;
     }
 }
 
@@ -662,20 +1036,20 @@
 
     switch(pEvdev->slots[slot].state)
     {
-        case SLOTSTATE_EMPTY:
-            return;
-        case SLOTSTATE_CLOSE:
-            type = XI_TouchEnd;
-            pEvdev->slots[slot].state = SLOTSTATE_EMPTY;
-            break;
-        case SLOTSTATE_OPEN:
-            type = XI_TouchBegin;
-            pEvdev->slots[slot].state = SLOTSTATE_UPDATE;
-            break;
-        case SLOTSTATE_UPDATE:
-        default:
-            type = XI_TouchUpdate;
-            break;
+    case SLOTSTATE_EMPTY:
+        return;
+    case SLOTSTATE_CLOSE:
+        type = XI_TouchEnd;
+        pEvdev->slots[slot].state = SLOTSTATE_EMPTY;
+        break;
+    case SLOTSTATE_OPEN:
+        type = XI_TouchBegin;
+        pEvdev->slots[slot].state = SLOTSTATE_UPDATE;
+        break;
+    case SLOTSTATE_UPDATE:
+    default:
+        type = XI_TouchUpdate;
+        break;
     }
 
     EvdevSwapAbsValuators(pEvdev, pEvdev->mt_mask);
@@ -738,11 +1112,11 @@
     {
         int slot_index = last_mt_vals_slot(pEvdev);
         if (slot_index < 0) {
-                    LogMessageVerbSigSafe(X_WARNING, 0,
-                                          "%s: Invalid slot index %d, touch events may be incorrect.\n",
-                                          pInfo->name,
-                                          slot_index);
-                    return;
+            LogMessageVerbSigSafe(X_WARNING, 0,
+                                  "%s: Invalid slot index %d, touch events may be incorrect.\n",
+                                  pInfo->name,
+                                  slot_index);
+            return;
         }
 
         pEvdev->slots[slot_index].dirty = 1;
@@ -787,13 +1161,14 @@
      * which is required by wheel emulation */
     map = pEvdev->abs_axis_map[ev->code];
     if (map < 2)
-            valuator_mask_set(pEvdev->abs_vals, map, value);
+        valuator_mask_set(pEvdev->abs_vals, map, value);
 
     if (EvdevWheelEmuFilterMotion(pInfo, ev))
         return;
 
     if (ev->code >= ABS_MT_SLOT) {
         EvdevProcessTouchEvent(pInfo, ev);
+        pEvdev->abs_queued = 1;
     } else if (!pEvdev->mt_mask) {
         map = pEvdev->abs_axis_map[ev->code];
 
@@ -838,31 +1213,31 @@
     }
 
     switch (ev->code) {
-        case BTN_TOUCH:
-            /* For devices that have but don't use proximity, use
-             * BTN_TOUCH as the proximity notifier */
-            if (!pEvdev->use_proximity)
-                pEvdev->in_proximity = value ? ev->code : 0;
-            /* When !pEvdev->use_proximity, we don't report
-             * proximity events to the X server. However, we
-             * still want to keep track if one is in proximity or
-             * not. This is especially important for touchpad
-             * who report proximity information to the computer
-             * (but it is not sent to X) and who might send unreliable
-             * position information when not in_proximity.
-             */
-
-            if (!(pEvdev->flags & (EVDEV_TOUCHSCREEN | EVDEV_TABLET)) ||
-                pEvdev->mt_mask)
-                break;
-            /* Treat BTN_TOUCH from devices that only have BTN_TOUCH as
-             * BTN_LEFT. */
-            ev->code = BTN_LEFT;
-            /* Intentional fallthrough! */
+    case BTN_TOUCH:
+        /* For devices that have but don't use proximity, use
+         * BTN_TOUCH as the proximity notifier */
+        if (!pEvdev->use_proximity)
+            pEvdev->in_proximity = value ? ev->code : 0;
+                /* When !pEvdev->use_proximity, we don't report
+                 * proximity events to the X server. However, we
+                 * still want to keep track if one is in proximity or
+                 * not. This is especially important for touchpad
+                 * who report proximity information to the computer
+                 * (but it is not sent to X) and who might send unreliable
+                 * position information when not in_proximity.
+                 */
+
+                if (!(pEvdev->flags & (EVDEV_TOUCHSCREEN | EVDEV_TABLET)) ||
+                    pEvdev->mt_mask)
+                    break;
+                /* Treat BTN_TOUCH from devices that only have BTN_TOUCH as
+                 * BTN_LEFT. */
+                ev->code = BTN_LEFT;
+                /* Intentional fallthrough! */
 
-        default:
-            EvdevProcessButtonEvent(pInfo, ev);
-            break;
+    default:
+        EvdevProcessButtonEvent(pInfo, ev);
+        break;
     }
 }
 
@@ -909,14 +1284,14 @@
 
     for (i = 0; pEvdev->prox_queued && i < pEvdev->num_queue; i++) {
         switch (pEvdev->queue[i].type) {
-            case EV_QUEUE_KEY:
-            case EV_QUEUE_BTN:
-            case EV_QUEUE_TOUCH:
-                break;
-            case EV_QUEUE_PROXIMITY:
-                if (pEvdev->queue[i].val == which)
-                    xf86PostProximityEventM(pInfo->dev, which, pEvdev->old_vals);
-                break;
+        case EV_QUEUE_KEY:
+        case EV_QUEUE_BTN:
+        case EV_QUEUE_TOUCH:
+            break;
+        case EV_QUEUE_PROXIMITY:
+            if (pEvdev->queue[i].val == which)
+                xf86PostProximityEvent(pInfo->dev, which, 0, 0);
+            break;
         }
     }
 }
@@ -928,13 +1303,24 @@
 {
     int i;
     EvdevPtr pEvdev = pInfo->private;
+    int ind = pEvdev->ahmQueueBottom;
 
     for (i = 0; i < pEvdev->num_queue; i++) {
         switch (pEvdev->queue[i].type) {
         case EV_QUEUE_KEY:
-            xf86PostKeyboardEvent(pInfo->dev, pEvdev->queue[i].detail.key,
-                                  pEvdev->queue[i].val);
+            /*
+             * ahm:
+             * In the original code, these key events are
+             * dispatched with xf86PostKeyboardEvent here.
+             * In ahm, they're queued, and sent asynchronously using timer.
+             * Actual flushing is done in AhmWakeupHandler.
+             */
+            pEvdev->ahmQueueKeys[ind] = pEvdev->queue[i].detail.key;
+            pEvdev->ahmQueueValues[ind] = pEvdev->queue[i].val;
+            ind++;
+            ind %= AHM_QUEUE_SIZE;
             break;
+
         case EV_QUEUE_BTN:
             if (Evdev3BEmuFilterEvent(pInfo,
                                       pEvdev->queue[i].detail.key,
@@ -943,7 +1329,7 @@
 
             if (pEvdev->abs_queued && pEvdev->in_proximity) {
                 xf86PostButtonEvent(pInfo->dev, Absolute, pEvdev->queue[i].detail.key,
-                                     pEvdev->queue[i].val, 0, 0);
+                                    pEvdev->queue[i].val, 0, 0);
 
             } else
                 xf86PostButtonEvent(pInfo->dev, Relative, pEvdev->queue[i].detail.key,
@@ -958,6 +1344,10 @@
             break;
         }
     }
+    if(pEvdev->flags & EVDEV_KEYBOARD_EVENTS){
+        pEvdev->ahmTimerExpires = GetTimeInMillis();
+        pEvdev->ahmQueueBottom = ind;
+    }
 }
 
 /**
@@ -1009,18 +1399,18 @@
 EvdevProcessEvent(InputInfoPtr pInfo, struct input_event *ev)
 {
     switch (ev->type) {
-        case EV_REL:
-            EvdevProcessRelativeMotionEvent(pInfo, ev);
-            break;
-        case EV_ABS:
-            EvdevProcessAbsoluteMotionEvent(pInfo, ev);
-            break;
-        case EV_KEY:
-            EvdevProcessKeyEvent(pInfo, ev);
-            break;
-        case EV_SYN:
-            EvdevProcessSyncEvent(pInfo, ev);
-            break;
+    case EV_REL:
+        EvdevProcessRelativeMotionEvent(pInfo, ev);
+        break;
+    case EV_ABS:
+        EvdevProcessAbsoluteMotionEvent(pInfo, ev);
+        break;
+    case EV_KEY:
+        EvdevProcessKeyEvent(pInfo, ev);
+        break;
+    case EV_SYN:
+        EvdevProcessSyncEvent(pInfo, ev);
+        break;
     }
 }
 
@@ -1076,7 +1466,7 @@
                 xf86RemoveEnabledDevice(pInfo);
             else if (rc != -EAGAIN)
                 LogMessageVerbSigSafe(X_ERROR, 0, "%s: Read error: %s\n", pInfo->name,
-                                       strerror(-rc));
+                                      strerror(-rc));
             break;
         } else if (rc == LIBEVDEV_READ_STATUS_SUCCESS) {
             if (pEvdev->mtdev)
@@ -1117,7 +1507,6 @@
     InputInfoPtr pInfo;
     struct input_event ev[ArrayLength(bits) + 1];
     int i;
-    int rc;
 
     memset(ev, 0, sizeof(ev));
 
@@ -1132,9 +1521,7 @@
     ev[i].code = SYN_REPORT;
     ev[i].value = 0;
 
-    rc = write(pInfo->fd, ev, sizeof ev);
-    if (rc != sizeof ev)
-	    xf86IDrvMsg(pInfo, X_ERROR, "Failed to set keyboard controls: %s\n", strerror(errno));
+    write(pInfo->fd, ev, sizeof ev);
 }
 
 static int
@@ -1142,7 +1529,7 @@
 {
     int rc = Success;
     XkbRMLVOSet rmlvo = {0},
-                defaults;
+        defaults;
     InputInfoPtr pInfo;
 
     pInfo = device->public.devicePrivate;
@@ -1192,11 +1579,11 @@
 {
     switch(axis)
     {
-        case ABS_MT_SLOT:
-        case ABS_MT_TRACKING_ID:
-            return TRUE;
-        default:
-            return FALSE;
+    case ABS_MT_SLOT:
+    case ABS_MT_TRACKING_ID:
+        return TRUE;
+    default:
+        return FALSE;
     }
 }
 
@@ -1247,7 +1634,7 @@
         return;
 
     /* Absolute multitouch axes: adjust mapping and axes counts. */
-    for (axis = ABS_MT_SLOT; axis <= ABS_MAX; axis++)
+    for (axis = ABS_MT_SLOT; axis < ABS_MAX; axis++)
     {
         int j;
         Bool skip = FALSE;
@@ -1297,7 +1684,7 @@
         goto out;
 
     /* Find number of absolute axis, including MT ones, will decrease later. */
-    for (i = 0; i <= ABS_MAX; i++)
+    for (i = 0; i < ABS_MAX; i++)
         if (libevdev_has_event_code(pEvdev->dev, EV_ABS, i))
             num_axes++;
 
@@ -1421,7 +1808,7 @@
             if (mt_axis_mappings[j].code == axis)
                 mt_axis_mappings[j].mapping = mapping;
             else if (mt_axis_mappings[j].mt_code == axis &&
-                    mt_axis_mappings[j].needs_mapping)
+                     mt_axis_mappings[j].needs_mapping)
                 mapping = mt_axis_mappings[j].mapping;
         }
         pEvdev->abs_axis_map[axis] = mapping;
@@ -1465,7 +1852,7 @@
         }
 
         for (i = 0; i < num_touches; i++) {
-            for (axis = ABS_MT_TOUCH_MAJOR; axis <= ABS_MAX; axis++) {
+            for (axis = ABS_MT_TOUCH_MAJOR; axis < ABS_MAX; axis++) {
                 if (pEvdev->abs_axis_map[axis] >= 0) {
                     int val = pEvdev->mtdev ? 0 : libevdev_get_current_slot(pEvdev->dev);
                     /* XXX: read initial values from mtdev when it adds support
@@ -1513,7 +1900,7 @@
 
         for (j = 0; j < ArrayLength(mt_axis_mappings); j++)
             if (mt_axis_mappings[j].mt_code == axis &&
-                    mt_axis_mappings[j].needs_mapping)
+                mt_axis_mappings[j].needs_mapping)
             {
                 skip = TRUE;
                 break;
@@ -1678,7 +2065,7 @@
     if (!libevdev_has_event_type(pEvdev->dev, EV_REL))
         goto out;
 
-    for (i = 0; i <= REL_MAX; i++) {
+    for (i = 0; i < REL_MAX; i++) {
         if (i == REL_WHEEL || i == REL_HWHEEL || i == REL_DIAL)
             continue;
 
@@ -1690,7 +2077,7 @@
        EvdevInitAbsValuators if possible */
     if (num_axes < 1 &&
         (num_scroll_axes == 0 || pEvdev->flags & EVDEV_ABSOLUTE_EVENTS))
-            goto out;
+        goto out;
 
     num_axes += num_scroll_axes;
 
@@ -1726,7 +2113,7 @@
 
     if (!InitPtrFeedbackClassDeviceStruct(device, EvdevPtrCtrlProc)) {
         xf86IDrvMsg(pInfo, X_ERROR, "failed to initialize pointer feedback class "
-                "device.\n");
+                    "device.\n");
         goto out;
     }
 
@@ -1920,9 +2307,9 @@
     pEvdev = pInfo->private;
 
     if (pEvdev->flags & EVDEV_KEYBOARD_EVENTS)
-	EvdevAddKeyClass(device);
+        EvdevAddKeyClass(device);
     if (pEvdev->flags & EVDEV_BUTTON_EVENTS)
-	EvdevAddButtonClass(device);
+        EvdevAddButtonClass(device);
 
     /* We don't allow relative and absolute axes on the same device. The
      * reason is that some devices (MS Optical Desktop 2000) register both
@@ -1985,6 +2372,7 @@
     xf86FlushInput(pInfo->fd);
     xf86AddEnabledDevice(pInfo);
     EvdevMBEmuOn(pInfo);
+    AhmRegisterTimers(pInfo);
     Evdev3BEmuOn(pInfo);
     pEvdev->flags |= EVDEV_INITIALIZED;
     device->public.on = TRUE;
@@ -2005,16 +2393,16 @@
     switch (what)
     {
     case DEVICE_INIT:
-	return EvdevInit(device);
+        return EvdevInit(device);
 
     case DEVICE_ON:
         return EvdevOn(device);
 
     case DEVICE_OFF:
-        if (pEvdev->flags & EVDEV_INITIALIZED)
-        {
+        if (pEvdev->flags & EVDEV_INITIALIZED){
             EvdevMBEmuFinalize(pInfo);
             Evdev3BEmuFinalize(pInfo);
+            AhmFinalise(pInfo);
         }
         if (pInfo->fd != -1)
         {
@@ -2024,15 +2412,15 @@
         }
         pEvdev->min_maj = 0;
         pEvdev->flags &= ~EVDEV_INITIALIZED;
-	device->public.on = FALSE;
-	break;
+        device->public.on = FALSE;
+        break;
 
     case DEVICE_CLOSE:
-	xf86IDrvMsg(pInfo, X_INFO, "Close\n");
+        xf86IDrvMsg(pInfo, X_INFO, "Close\n");
         EvdevCloseDevice(pInfo);
         EvdevFreeMasks(pEvdev);
         pEvdev->min_maj = 0;
-	break;
+        break;
 
     default:
         return BadValue;
@@ -2144,7 +2532,7 @@
        - unset: do the normal thing.
        - TRUE: explicitly ignore them.
        - FALSE: unignore axes, use them at all cost if they're present.
-     */
+    */
     if (xf86FindOption(pInfo->options, "IgnoreRelativeAxes"))
     {
         if (xf86SetBoolOption(pInfo->options, "IgnoreRelativeAxes", FALSE))
@@ -2156,7 +2544,7 @@
     if (xf86FindOption(pInfo->options, "IgnoreAbsoluteAxes"))
     {
         if (xf86SetBoolOption(pInfo->options, "IgnoreAbsoluteAxes", FALSE))
-           ignore_abs = TRUE;
+            ignore_abs = TRUE;
         else
             pEvdev->flags |= EVDEV_UNIGNORE_ABSOLUTE;
     }
@@ -2182,8 +2570,8 @@
     }
 
     has_lmr = libevdev_has_event_code(pEvdev->dev, EV_KEY, BTN_LEFT) ||
-              libevdev_has_event_code(pEvdev->dev, EV_KEY, BTN_MIDDLE) ||
-              libevdev_has_event_code(pEvdev->dev, EV_KEY, BTN_RIGHT);
+        libevdev_has_event_code(pEvdev->dev, EV_KEY, BTN_MIDDLE) ||
+        libevdev_has_event_code(pEvdev->dev, EV_KEY, BTN_RIGHT);
 
     if (num_buttons)
     {
@@ -2298,10 +2686,10 @@
                 }
             } else if (!(libevdev_has_event_code(pEvdev->dev, EV_REL, REL_X) &&
                          libevdev_has_event_code(pEvdev->dev, EV_REL, REL_Y)) && has_lmr) {
-                    /* some touchscreens use BTN_LEFT rather than BTN_TOUCH */
-                    xf86IDrvMsg(pInfo, X_PROBED, "Found absolute touchscreen\n");
-                    pEvdev->flags |= EVDEV_TOUCHSCREEN;
-                    pEvdev->flags |= EVDEV_BUTTON_EVENTS;
+                /* some touchscreens use BTN_LEFT rather than BTN_TOUCH */
+                xf86IDrvMsg(pInfo, X_PROBED, "Found absolute touchscreen\n");
+                pEvdev->flags |= EVDEV_TOUCHSCREEN;
+                pEvdev->flags |= EVDEV_BUTTON_EVENTS;
             }
         } else {
             if (!libevdev_has_event_code(pEvdev->dev, EV_ABS, ABS_MT_POSITION_X) ||
@@ -2337,8 +2725,8 @@
         str = xf86CheckStrOption(pInfo->options, "Calibration", NULL);
         if (str) {
             num_calibration = sscanf(str, "%d %d %d %d",
-                    &calibration[0], &calibration[1],
-                    &calibration[2], &calibration[3]);
+                                     &calibration[0], &calibration[1],
+                                     &calibration[2], &calibration[3]);
             free(str);
             if (num_calibration == 4)
                 EvdevSetCalibration(pInfo, num_calibration, calibration);
@@ -2351,25 +2739,23 @@
 
     if (has_rel_axes || has_abs_axes || num_buttons) {
         pInfo->flags |= XI86_SEND_DRAG_EVENTS;
-	if (pEvdev->flags & EVDEV_TOUCHPAD) {
-	    xf86IDrvMsg(pInfo, X_INFO, "Configuring as touchpad\n");
-	    pInfo->type_name = XI_TOUCHPAD;
-	    pEvdev->use_proximity = 0;
-	} else if (pEvdev->flags & EVDEV_TABLET) {
-	    xf86IDrvMsg(pInfo, X_INFO, "Configuring as tablet\n");
-	    pInfo->type_name = XI_TABLET;
+        if (pEvdev->flags & EVDEV_TOUCHPAD) {
+            xf86IDrvMsg(pInfo, X_INFO, "Configuring as touchpad\n");
+            pInfo->type_name = XI_TOUCHPAD;
+            pEvdev->use_proximity = 0;
+        } else if (pEvdev->flags & EVDEV_TABLET) {
+            xf86IDrvMsg(pInfo, X_INFO, "Configuring as tablet\n");
+            pInfo->type_name = XI_TABLET;
         } else if (pEvdev->flags & EVDEV_TOUCHSCREEN) {
             xf86IDrvMsg(pInfo, X_INFO, "Configuring as touchscreen\n");
             pInfo->type_name = XI_TOUCHSCREEN;
-	} else {
+        } else {
             if (!libevdev_has_event_code(pEvdev->dev, EV_REL, REL_X) ||
-                !libevdev_has_event_code(pEvdev->dev, EV_REL, REL_Y)) {
-                pEvdev->flags |= EVDEV_RELATIVE_EVENTS;
+                !libevdev_has_event_code(pEvdev->dev, EV_REL, REL_Y))
                 EvdevForceXY(pInfo, Relative);
-            }
-	    xf86IDrvMsg(pInfo, X_INFO, "Configuring as mouse\n");
-	    pInfo->type_name = XI_MOUSE;
-	}
+            xf86IDrvMsg(pInfo, X_INFO, "Configuring as mouse\n");
+            pInfo->type_name = XI_MOUSE;
+        }
 
         rc = 0;
     }
@@ -2497,7 +2883,7 @@
     }
 
     if (pInfo->fd < 0) {
-        xf86IDrvMsg(pInfo, X_ERROR, "Unable to open evdev device \"%s\" (%s).\n", device, strerror(errno));
+        xf86IDrvMsg(pInfo, X_ERROR, "Unable to open evdev device \"%s\".\n", device);
         return BadValue;
     }
 
@@ -2654,7 +3040,7 @@
 
     /* Overwrite type_name with custom-defined one (#62831).
        Note: pInfo->type_name isn't freed so we need to manually do this
-     */
+    */
     pEvdev->type_name = xf86SetStrOption(pInfo->options,
                                          "TypeName",
                                          pInfo->type_name);
@@ -2668,6 +3054,121 @@
         EvdevDragLockPreInit(pInfo);
     }
 
+    if (pEvdev->flags & EVDEV_KEYBOARD_EVENTS)
+    {
+        /* parse ahm options */
+        char *str, *toFree;
+        char *next = NULL;
+        char *end = NULL;
+        int fromCode = 0, toCode = 0;
+
+        pEvdev->ahmQueueTop = 0;
+        pEvdev->ahmQueueBottom = 0;
+
+        pEvdev->lastPressCode = 0;
+        pEvdev->lastValue = 0;
+        pEvdev->lastPlainPressTime = 0;
+
+        for(fromCode = 0; fromCode < 256; fromCode++){
+            pEvdev->transModCount[fromCode] = 0;
+            pEvdev->transModTable[fromCode] = 0;
+            pEvdev->transModFreeze[fromCode] = 0;
+            pEvdev->ahmDelayTable[fromCode] = 0;
+            pEvdev->transModPressed[fromCode] = 0;
+            pEvdev->ahmTimePressed[fromCode] = 0;
+        }
+
+        /* set timeout for ahm */
+        pEvdev->ahmTimeout = xf86SetIntOption(pInfo->options, "AhmTimeout", 600);
+        pEvdev->lastEventTime.tv_sec = 0;
+        pEvdev->lastEventTime.tv_usec = 0;
+
+        pEvdev->ahmDelayedKeys = 0;
+
+        pEvdev->ahmPaddingInterval = xf86SetIntOption(pInfo->options, "AhmPaddingInterval", 10);
+        /* Negative padding doesn't harm. */
+        pEvdev->ahmFreezeTT = xf86SetBoolOption(pInfo->options, "AhmFreezeTT", 1);
+
+        pEvdev->ahmResetTime = xf86SetIntOption(pInfo->options, "AhmResetTime", 10);
+
+        /* parse "transMod" option */
+        str = xf86CheckStrOption(pInfo->options, "TransMod",NULL);
+        if(str){
+            xf86Msg(X_CONFIG, "Option \"TransMod\" \"%s\"\n", str);
+            toFree = str;
+            next = str;
+            while(next != NULL){
+                fromCode = strtol(next, &end, 10);
+                if (next == end){
+                    break;
+                }
+                if (*end != ':'){
+                    xf86IDrvMsg(pInfo, X_ERROR, "TransMod : "
+                                "Dest keycode is lacking; colon expected: %s\n",
+                                str);
+                    break;
+                }
+                end++;
+                next = end;
+                toCode = strtol(next, &end, 10);
+                if(next == end){
+                    xf86IDrvMsg(pInfo, X_ERROR, "TransMod : "
+                                "Dest keycode is lacking: %s\n",
+                                str);
+                }
+                next = end;
+                /* xxx do range check, and store */
+                xf86IDrvMsg(pInfo, X_CONFIG, "TransMod: %i -> %i\n",
+                            fromCode, toCode);
+                if((fromCode < MIN_KEYCODE) || (fromCode > 255)){
+                    xf86IDrvMsg(pInfo, X_ERROR, "TransMod : "
+                                "Keycode out of range: %i\n",
+                                fromCode);
+                    continue;
+                }
+                /* dest keycode has to be <= 255, due to X limit. */
+                if((toCode < MIN_KEYCODE) || (toCode > 255)){
+                    xf86IDrvMsg(pInfo, X_ERROR, "TransMod : "
+                                "Keycode out of range: %i\n",
+                                toCode);
+                    continue;
+                }
+                pEvdev->transModTable[fromCode] = toCode;
+            }
+            free(toFree);
+        }
+
+        /* parse option "AhmDelay" */
+        str = xf86CheckStrOption(pInfo->options, "AhmDelay", NULL);
+        if(str){
+            xf86Msg(X_CONFIG, "Option \"AhmDelay\" \"%s\"\n", str);
+            toFree = str;
+            next = str;
+            while(next != NULL){
+                fromCode = strtol(next, &end, 10);
+                if (next == end){
+                    break;
+                }
+                next = end;
+
+                /* do range check, and store */
+                if((fromCode < MIN_KEYCODE) || (fromCode > 255)){
+                    xf86IDrvMsg(pInfo, X_ERROR, "AhmDelay : "
+                                "Keycode out of range: %i\n",
+                                fromCode);
+                    continue;
+                }
+                if(pEvdev->transModTable[fromCode] == 0){
+                    xf86IDrvMsg(pInfo, X_WARNING, "warning: Delay key %i is not a transmod.\n", fromCode);
+                }
+                pEvdev->ahmDelayTable[fromCode] = 1;
+            }
+            free(toFree);
+        }
+
+        /* end of parsing ahm options */
+    }
+
     return Success;
 
 error:
@@ -2734,29 +3235,29 @@
     switch (code)
     {
         /* Mouse buttons */
-        case BTN_LEFT:
-            return 1;
-        case BTN_MIDDLE:
-            return 2;
-        case BTN_RIGHT:
-            return 3;
-        case BTN_SIDE ... BTN_JOYSTICK - 1:
-            return 8 + code - BTN_SIDE;
+    case BTN_LEFT:
+        return 1;
+    case BTN_MIDDLE:
+        return 2;
+    case BTN_RIGHT:
+        return 3;
+    case BTN_SIDE ... BTN_JOYSTICK - 1:
+        return 8 + code - BTN_SIDE;
 
         /* Generic buttons */
-        case BTN_0 ... BTN_2:
-            return 1 + code - BTN_0;
-        case BTN_3 ... BTN_MOUSE - 1:
-            return 8 + code - BTN_3;
+    case BTN_0 ... BTN_2:
+        return 1 + code - BTN_0;
+    case BTN_3 ... BTN_MOUSE - 1:
+        return 8 + code - BTN_3;
 
         /* Tablet stylus buttons */
-        case BTN_TOUCH ... BTN_STYLUS2:
-            return 1 + code - BTN_TOUCH;
+    case BTN_TOUCH ... BTN_STYLUS2:
+        return 1 + code - BTN_TOUCH;
 
         /* The rest */
-        default:
-            /* Ignore */
-            return 0;
+    default:
+        /* Ignore */
+        return 0;
     }
 }
 
@@ -2892,15 +3393,15 @@
         prop_invert = MakeAtom(EVDEV_PROP_INVERT_AXES, strlen(EVDEV_PROP_INVERT_AXES), TRUE);
 
         rc = XIChangeDeviceProperty(dev, prop_invert, XA_INTEGER, 8,
-                PropModeReplace, 2,
-                invert, FALSE);
+                                    PropModeReplace, 2,
+                                    invert, FALSE);
         if (rc != Success)
             return;
 
         XISetDevicePropertyDeletable(dev, prop_invert, FALSE);
 
         prop_calibration = MakeAtom(EVDEV_PROP_CALIBRATION,
-                strlen(EVDEV_PROP_CALIBRATION), TRUE);
+                                    strlen(EVDEV_PROP_CALIBRATION), TRUE);
         if (pEvdev->flags & EVDEV_CALIBRATED) {
             int calibration[4];
 
@@ -2910,12 +3411,12 @@
             calibration[3] = pEvdev->calibration.max_y;
 
             rc = XIChangeDeviceProperty(dev, prop_calibration, XA_INTEGER,
-                    32, PropModeReplace, 4, calibration,
-                    FALSE);
+                                        32, PropModeReplace, 4, calibration,
+                                        FALSE);
         } else if (pEvdev->flags & EVDEV_ABSOLUTE_EVENTS) {
             rc = XIChangeDeviceProperty(dev, prop_calibration, XA_INTEGER,
-                    32, PropModeReplace, 0, NULL,
-                    FALSE);
+                                        32, PropModeReplace, 0, NULL,
+                                        FALSE);
         }
         if (rc != Success)
             return;
@@ -2923,10 +3424,10 @@
         XISetDevicePropertyDeletable(dev, prop_calibration, FALSE);
 
         prop_swap = MakeAtom(EVDEV_PROP_SWAP_AXES,
-                strlen(EVDEV_PROP_SWAP_AXES), TRUE);
+                             strlen(EVDEV_PROP_SWAP_AXES), TRUE);
 
         rc = XIChangeDeviceProperty(dev, prop_swap, XA_INTEGER, 8,
-                PropModeReplace, 1, &pEvdev->swap_axes, FALSE);
+                                    PropModeReplace, 1, &pEvdev->swap_axes, FALSE);
         if (rc != Success)
             return;
 
diff -ru xf86-input-evdev-2.10.6/src/evdev.h at-home-modifier-evdev/src/evdev.h
--- xf86-input-evdev-2.10.6/src/evdev.h	2018-05-28 19:33:18.000000000 -0700
+++ at-home-modifier-evdev/src/evdev.h	2019-06-03 10:30:27.481598779 -0700
@@ -37,6 +37,7 @@
 
 #include <linux/input.h>
 #include <linux/types.h>
+#include <sys/time.h>
 
 #include <xorg-server.h>
 #include <xf86Xinput.h>
@@ -67,18 +68,6 @@
 #define LogMessageVerbSigSafe xf86MsgVerb
 #endif
 
-#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 23
-#define HAVE_THREADED_INPUT	1
-#endif
-
-#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 24
-#define BLOCK_HANDLER_ARGS     	void *data, void *waitTime
-#define WAKEUP_HANDLER_ARGS	void *data, int i
-#else
-#define BLOCK_HANDLER_ARGS	pointer data, struct timeval **waitTime, pointer LastSelectMask
-#define WAKEUP_HANDLER_ARGS	void *data, int i, pointer LastSelectMask
-#endif
-
 #define EVDEV_MAXBUTTONS 32
 #define EVDEV_MAXQUEUE 32
 
@@ -100,6 +89,13 @@
 #define MAX_VALUATORS 36
 #endif
 
+#define AHM_QUEUE_SIZE 256
+
+/* If we're not using GNU C, nuke __attribute__ */
+#ifndef __GNUC__
+#  define  __attribute__(x)  /*NOTHING*/
+#endif
+
 #ifndef XI_PROP_DEVICE_NODE
 #define XI_PROP_DEVICE_NODE "Device Node"
 #endif
@@ -188,6 +184,39 @@
 
     unsigned int abs_queued, rel_queued, prox_queued;
 
+  /* ahm variables */
+  int                 lastPressCode;
+  int                 lastValue;
+  unsigned int        transModTable[256]; /* [orig keycode] means translated keycode */
+  int                 transModCount[256]; /* records how many times fold the translated key is pressed */
+  unsigned int        transModFreeze[256]; /* 1 means temporarily transmod is frozen. */
+
+  unsigned int        transModPressed[256]; /* 1 means we pressed the transMod (so that we release later) */
+
+  Time                ahmTimePressed[256];
+    Time                lastPlainPressTime; 
+   
+    
+  int                 ahmTimeout;
+  struct timeval      lastEventTime;
+
+  int                 ahmDelayTable[256];
+  int                 ahmDelayedCode[2];
+  int                 ahmDelayedKeys;
+  int                 ahmResetTime;
+
+  int                 ahmFreezeTT;
+
+  /* queuing variables */
+  int                 ahmPaddingInterval;
+  Time                ahmTimerExpires;
+  int                 ahmQueueKeys[AHM_QUEUE_SIZE];
+  int                 ahmQueueValues[AHM_QUEUE_SIZE];
+  int                 ahmQueueTop; /* Dispatch from here */
+  int                 ahmQueueBottom; /* Queue from here */
+
+  /* end of ahm variables */
+
     /* Middle mouse button emulation */
     struct {
         BOOL                enabled;
@@ -196,7 +225,6 @@
         int                 state;       /* state machine (see bt3emu.c) */
         Time                expires;     /* time of expiry */
         Time                timeout;
-        uint8_t             button;      /* phys button to emit */
     } emulateMB;
     /* Third mouse button emulation */
     struct emulate3B {
@@ -259,7 +287,11 @@
 } EvdevRec, *EvdevPtr;
 
 /* Event posting functions */
-void EvdevQueueKbdEvent(InputInfoPtr pInfo, struct input_event *ev, int value);
+/*
+ * ahm changed the type. originally:
+ * void EvdevQueueKbdEvent(InputInfoPtr pInfo, struct input_event *ev, int value);
+ */
+int EvdevQueueKbdEvent(InputInfoPtr pInfo, struct input_event *ev, int value);
 void EvdevQueueButtonEvent(InputInfoPtr pInfo, int button, int value);
 void EvdevQueueProximityEvent(InputInfoPtr pInfo, int value);
 void EvdevQueueTouchEvent(InputInfoPtr pInfo, unsigned int touch,
@@ -273,8 +305,8 @@
 /* Middle Button emulation */
 int  EvdevMBEmuTimer(InputInfoPtr);
 BOOL EvdevMBEmuFilterEvent(InputInfoPtr, int, BOOL);
-void EvdevMBEmuWakeupHandler(WAKEUP_HANDLER_ARGS);
-void EvdevMBEmuBlockHandler(BLOCK_HANDLER_ARGS);
+void EvdevMBEmuWakeupHandler(pointer, int, pointer);
+void EvdevMBEmuBlockHandler(pointer, struct timeval**, pointer);
 void EvdevMBEmuPreInit(InputInfoPtr);
 void EvdevMBEmuOn(InputInfoPtr);
 void EvdevMBEmuFinalize(InputInfoPtr);
